const int NUM_CASCADES = 4;

float CalcShadowFactor(sampler2D texShadowmap[NUM_CASCADES], int CascadeIndex, vec4 positionLS, vec3 normal, vec3 lightDirection)
{
    const float angleBias = 0.006;

    vec3 ProjCoords = positionLS.xyz / positionLS.w;
    vec3 UVCoords = 0.5 * ProjCoords + 0.5;
    float Depth = texture(texShadowmap[CascadeIndex], UVCoords.xy).x;
    float bias = max(angleBias * (1.0 - dot(normal, -lightDirection)), 0.0008);
    if (UVCoords.z - bias > Depth)
        return 0.3;
    return 1.0;
}

float CalcShadowCascaded(
    float clipSpacePosZ,
    float cascadeEndClipSpace[NUM_CASCADES],
    sampler2D texShadowmap[NUM_CASCADES],
    vec4 positionLS[NUM_CASCADES],
    vec3 normal,
    vec3 lightDirection,
    out vec4 CascadeIndicator)
{
    float ShadowFactor = 0.0;
    for (int i = 0; i < NUM_CASCADES; i++)
    {
        if (clipSpacePosZ <= cascadeEndClipSpace[i]) {
            ShadowFactor = CalcShadowFactor(texShadowmap, i, positionLS[i], normal, lightDirection);
            if (i == 0)
                CascadeIndicator = vec4(0.3, 0.0, 0.0, 0.0);
            else if (i == 1)
                CascadeIndicator = vec4(0.0, 0.3, 0.0, 0.0);
            else if (i == 2)
                CascadeIndicator = vec4(0.0, 0.0, 0.3, 0.0);
            break;
        }
    }
    return ShadowFactor;
}

